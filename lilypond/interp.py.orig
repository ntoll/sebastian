import re

MIDI_NOTE_VALUES = {
    "c": 0,
    "d": 2,
    "e": 4,
    "f": 5,
    "g": 7,
    "a": 9,
    "b": 11,
}

# Cutting up the regex into manageable components - helps with testing
RE_NOTE = "(?P<note>[abcdefg])"
RE_8VE = "(?P<octave>'+|,+)"
RE_REST = "(?P<rest>r)"
RE_DURATION = "(?P<duration>\d+\.*)"
RE_SHARP = "(?P<sharp>(is)*)"
RE_FLAT = "(?P<flat>(es)*)"
RE_ACCIDENTALS = "(%s%s)?"%(RE_SHARP, RE_FLAT)

token_pattern = re.compile(r"""^\s*                 # INITIAL WHITESPACE
    (
        (                                           # NOTE
            (
                (?P<note>[abcdefg])                     # NOTE NAME
                (?P<octave>'+|,+) ?                     # OCTAVE ?
                ((?P<sharp>(is)+)|(?P<flat>(es)+)) ?    # ACCIDENTALS ?
                (=(?P<octave_check>'+|,+)) ?            # OCTAVE CHECK ?
                |                                       # or
                (?P<rest>r)                             # REST
            )
            (?P<duration>\d+\.*) ?                      # DURATION ?
            (\s*(?P<tie>~)) ?                           # TIE ?
        )
        |                                           # or
        \\(?P<command>(relative))                   # COMMANDS
        |                                           # or
        (?P<open_brace>{) | (?P<close_brace>})      # { or }
    )
    """, 
    re.VERBOSE
)


def tokenize(s):
    while True:
        if s:
            m = token_pattern.match(s)
            if m:
                yield m.groupdict()
            else:
                raise Exception("unknown token at: '%s'" % s[:20])
            s = s[m.end():]
        else:
            raise StopIteration

<<<<<<< HEAD:lilypond/interp.py
def parse(s):
    duration = 16
    curr_octave = 4
    offset = 0
    token_matcher = "(%s%s?%s|%s)%s?"%(RE_NOTE, RE_8VE, RE_ACCIDENTALS, RE_REST,
            RE_DURATION)
    
    for token in tokenize(s):
        m = re.match(token_matcher, token)
        if m:
            note = m.groupdict()["note"]
            octave_marker = m.groupdict()["octave"]
            duration_marker = m.groupdict()["duration"]
            accidental_sharp = m.groupdict()["sharp"]
            accidental_flat = m.groupdict()["flat"]
            rest = m.groupdict()["rest"]
            accidental_change = 0
            print m.groupdict()
=======

def note_tuple(token_dict, relative_note_tuple=None):
    note = token_dict["note"]
    octave_marker = token_dict["octave"]
    accidental_sharp = token_dict["sharp"]
    accidental_flat = token_dict["flat"]
    accidental_change = 0
    
    if relative_note_tuple:
        prev_note, prev_accidental_change, prev_octave = relative_note_tuple
        
        diff = MIDI_NOTE_VALUES[note] - prev_note
        if diff >= 7:
            base_octave = prev_octave - 1
        elif diff <= -7:
            base_octave = prev_octave + 1
        else:
            base_octave = prev_octave
    else:
        base_octave = 4
    
    if octave_marker is None:
        octave = base_octave
    elif "'" in octave_marker:
        octave = base_octave + len(octave_marker)
    elif "," in octave_marker:
        octave = base_octave - len(octave_marker)
    if accidental_sharp:
        accidental_change += len(accidental_sharp) / 2
    if accidental_flat:
        accidental_change -= len(accidental_flat) / 2
    
    return MIDI_NOTE_VALUES[note], accidental_change, octave


def parse_duration(duration_marker):
    if "." in duration_marker:
        first_dot = duration_marker.find(".")
        core = int(duration_marker[:first_dot])
        # this doesn't actually check they are all dots, but regex wouldn't
        # match in the first place otherwise
        dots = len(duration_marker[first_dot:])
    else:
        core = int(duration_marker)
        dots = 0
    
    duration = (2 - (2**-dots)) * 64 / core
    
    return duration


def parse_block(token_generator, prev_note_tuple = None, relative_mode = False, offset = 0):
    prev_duration = 16
    tie_deferred = False
    
    while True:
        token_dict = token_generator.next()
        
        command = token_dict["command"]
        open_brace = token_dict["open_brace"]
        close_brace = token_dict["close_brace"]
        
        if command:
            if command == "relative":
                
                token_dict = token_generator.next()
                
                base_note_tuple = note_tuple(token_dict)
                
                token_dict = token_generator.next()
                if not token_dict["open_brace"]:
                    raise Exception("\\relative must be followed by note then {...} block")
                
                for obj in parse_block(token_generator, prev_note_tuple=base_note_tuple, relative_mode=True, offset=offset):
                    yield obj
        elif open_brace:
            for obj in parse_block(token_generator):
                yield obj
        elif close_brace:
            raise StopIteration
        else:
            duration_marker = token_dict["duration"]
            rest = token_dict["rest"]
            tie = token_dict["tie"]
            
>>>>>>> 07dca05617550d47ced26b27dab27063435e3816:lilypond/interp.py
            if duration_marker is None:
                duration = prev_duration
            else:
                duration = parse_duration(duration_marker)
            
            if not rest:
                if relative_mode:
                    note_base, accidental_change, octave = note_tuple(token_dict, relative_note_tuple=prev_note_tuple)
                else:
<<<<<<< HEAD:lilypond/interp.py
                    octave = curr_octave
                if accidental_sharp:
                    accidental_change+=len(accidental_sharp)/2
                if accidental_flat:
                    accidental_change-=len(accidental_flat)/2
                note_value = MIDI_NOTE_VALUES[note] + (12 * octave) +\
                        accidental_change
                yield (offset, note_value, duration)
            offset += duration
        else:
            raise Exception("unsupported token %s" % token)
=======
                    note_base, accidental_change, octave = note_tuple(token_dict)
                note_value = note_base + (12 * octave) + accidental_change
                
                if tie_deferred:
                    # if the previous note was deferred due to a tie
                    prev_note_value = prev_note_tuple[0] + (12 * prev_note_tuple[2]) + prev_note_tuple[1]
                    if note_value != prev_note_value:
                        raise Exception("ties are only supported between notes of same pitch")
                    duration += prev_duration
                    tie_deferred = False
                
                if tie:
                    # if there is a tie following this note, we defer it
                    tie_deferred = True
                else:
                    yield (offset, note_value, duration)
                
                prev_note_tuple = note_base, accidental_change, octave
            
            if not tie_deferred:
                offset += duration
            
            prev_duration = duration


def parse(s):
    return parse_block(tokenize(s))
>>>>>>> 07dca05617550d47ced26b27dab27063435e3816:lilypond/interp.py
